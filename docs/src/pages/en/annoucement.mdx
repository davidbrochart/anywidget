---
title: "Hello, anywidget"
layout: ../../layouts/MainLayout.astro
draft: true
---

_This post describes a new Python library called [**anywidget**](https://github.com/manzt/anywidget),
which simplifies authoring and publishing custom Jupyter widgets. **anywidget** allows you to
write code like this,_

```python
import anywidget
import traitlets


class HelloWidget(anywidget.AnyWidget):
    _esm = """
    export function render(view) {
        function update() {
            view.el.textContent = `Hello, ${view.model.get("name") ?? "world"}`;
        };
        update();
        view.model.on("change:name", update);
    }
    """
    name = traitlets.Unicode().tag(sync=True)

widget = HelloWidget()
widget.name = "anywidget";
widget
```

_... to create custom widgets that work in Jupyter notebooks, JupyterLab, Google Colab,
VS&nbsp;Code, and more. No messy build configuration or complicated cookiecutter templates._

## Motivation

Computational notebooks are ubiquitous in data analysis and programming education.
[Jupyter](https://jupyter.org/) is the _de facto_ standard in the Python world,
providing a web-based interface to execute code and embed computational outputs
with prose or multimedia in a single document. Its modular design enables users
to modify behavior and extend functionality to fit custom workflows.

[Jupyter Widgets](https://ipywidgets.readthedocs.io/en/stable/) is the official
_framework_ to extend notebook output cells in the browser with interactive
views or controls for Python objects in the Jupyter kernel. Custom widgets are a
important component of the Jupyter ecosystem because they enable interactive
data exploration and visualization **during analysis**.

A custom widget is composed of two separate programs:

- Python code that runs in the notebook kernel
- JavaScript code that renders the widget in the browser and communicates
  with the Python module

<center>
	<img
		alt="two components of a Jupyter widget, the JS fronend and Python backend"
		style="width: 100%; max-width: 600px;"
		src="/widget-overview.png"
	></img>
</center>

With the rise in popularity of Jupyter notebooks, other computational environments
and IDEs have implemented support for `.ipynb`. While this standardization is a largely
beneficial to the community, these tools vary in their support for extensions and
specifically Jupyter Widgets. The primary challenge is that the application frontend
must **discover** the JavaScript for the desired widget and **load and execute** the codeâ€“a
process which is not shared across implmentations since the tools are built with
different technologies. Widget authors are thus not only tasked with packaging their
JavaScript correctly for Jupyter notebooks but for several targets, each with their own
quirks.

<center>
	<img
		alt="two components of a Jupyter widget, the JS fronend and Python backend"
		style="width: 100%; max-width: 600px;"
		src="/client-js-diagram.png"
	></img>
</center>

An official solution to this multi-platform problem is provided by the Jupyter team in the from
of [cookiecutter templates](https://github.com/jupyter-widgets/?q=cookiecutter&type=all&language=&sort=).
However, the derived templates are bootstrapped with complicated packaging and distribution
scripts which must ultimately be maintained by the widget author.

The Official

My research entails developing visualization tools to connect biomedical researchers with their data.

However, making these tools correctly is ever challenging.

The development cycle typically looks like:

- Develop JS/HTML/CSS library

- Create cookiecutter template.

The last step is porting to Python, and every time we try to expose the Python interface it changes.

> This should be easier.

The issue is not fault of the developers but rather that the expectation is that widget run everywhere, but
in order for widgets to run everywhere there is a lot of burden placed on the developer to target these platforms.

As a researcher, I want a tool in which I can

- quickly prototype ideas

- publish to run in all environments with minimal effort

with many other software tools

. The interoperability
of notebooks in various IDEs and notebook environments (i.e., VS Code or Google Colab)

// TODO: link to patcher lab results
As such, a world of reproducibility has opened up to allow researchers with a click of
a button spin up notebooks and reproduce results in the cloud for free.

//
Jupyter is the de factor standard and as such many "Jupyter-like" platforms have emerged,
including Google Colab which is widely popular. Colab is based on the open source Jupyter project
and allow you to use and share Jupyter notebooks.

The rise of computational notebook environments h
Computational notebook environments have become an increasingly popular tool for sharing

Interactive computational notebook environments

[Jupyter widgets](https://ipywidgets.readthedocs.io/en/stable/) are

Thesis:

Jupyter is the de facto standard for computational notebooks, and as such many tools
include support for Jupyter notebooks. These notebooks are web-based, and Jupyter exposes
a mechanism that ties together Python code running in the "kernel" with the JavaScript/HTML/CSS
runnin in the browser.

Widgets enable users to extend notebooks with custom visualizations/views using web-technologies,
and enable users to explore their code and data interactively.

Anywidget asserts two things:

- Loading data from a CDN is no big deal
- Making widgets should be fun and easy
- Many Python widgets just need a little bit of boilerplate to connect the JavaScript
  library with the IPython comm system.

## How It Works

## A Simple Example

#
