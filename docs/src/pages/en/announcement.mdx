---
title: "anywidget: Custom Jupyter Widgets Made Easy"
layout: ../../layouts/MainLayout.astro
authors: ["Trevor Manz"]
---

import CounterButton from "../../components/CounterButton.astro";
import ConfettiButton from "../../components/ConfettiButton.astro";

_This post describes a new Python library called
[**anywidget**](https://github.com/manzt/anywidget), which simplifies authoring
and publishing custom Jupyter widgets. **anywidget** allows you to write code
like this,_

```python
import anywidget
import traitlets


class CounterWidget(anywidget.AnyWidget):
    _esm = """
    export function render(view) {
      let count = () => view.model.get("value");
      let btn = document.createElement("button");
      btn.innerHTML = `count is ${count()}`;
      btn.addEventListener("click", () => {
        view.model.set("value", count() + 1);
        view.model.save_changes();
      });
      view.model.on("change:value", () => {
        btn.innerHTML = `count is ${count()}`;
      });
      view.el.appendChild(btn);
    }
    """
    value = traitlets.Int(0).tag(sync=True)
```

_... to create custom widgets that work in Jupyter notebooks, JupyterLab, Google
Colab, VS&nbsp;Code, and more. No messy build configuration or complicated
cookiecutter templates._

## Rise of Jupyter

Computational notebooks are ubiquitous in data analysis and programming
education. [Jupyter](https://jupyter.org/) is the _de facto_ standard in the
Python world, providing a web-based interface to execute code and embed
computational outputs with prose or multimedia in a single document. Its modular
design enables users to modify behavior and extend functionality to fit custom
workflows.

[Jupyter Widgets](https://ipywidgets.readthedocs.io/en/stable/) is the official
framework to extend notebook output cells in the browser with interactive
views or controls for Python objects in the Jupyter kernel. Custom widgets enable interactive data
exploration and visualization **during analysis**. Widgets connect Python code
to responsive and sophisticated user interfaces built with modern web
technologies, bridging the gap between the web platform and Python ecosystem.

A custom widget is composed of two separate programs:

- Python code that runs in the notebook kernel
- JavaScript code that renders the widget in the browser and communicates with
  Python

![two components of a Jupyter widget, the JS frontend and Python backend](/widget-overview.png)

## The Multi-Platform Problem

With the rise in popularity of Jupyter notebooks, other computational
environments and IDEs (e.g., JupyterLab, Google Colab, VS Code) have implemented
support for `.ipynb`. However, these tools have varying degrees of support for extensions and Jupyter Widgets. The primary challenge is that each application
must **discover** the frontend widget code and **load** and **execute** the
JavaScript–a process which is not standardized like loading the associated
Python program in the application kernel.

Widget authors are thus not only tasked with packaging their JavaScript
correctly for Python but also for ensuring it can be used in multiple notebook environments, each with their own requirements
and quirks.

![Widget frontend source code (JavaScript) requires is transformed and packaged into separate files for JupyterLab, Jupyter notebooks, Google Colab, VS Code](/client-js-diagram.png)

To a seasoned frontend engineer, this problem likely appears well suited for a
JavaScript
[_bundler_](https://dev.to/underscorecode/javascript-bundlers-an-in-depth-comparative-is-webpack-still-the-best-bundler-in-2021-59jk),
and it largely is. The issue is that **every widget author is tasked with solving the
same multi-platform problem**, and the solution requires long-term maintenance.
Not only must the JavaScript tooling stay up to date with the fast-moving front-end ecosystem,
but the bundler configuration must be adapted to the latest – and mostly undocumented – requirements imposed by each notebook environment.

## A Solution with Crumbs

The Jupyter team provides a recommend approach to resolve this issue in the form of
[cookiecutters](https://github.com/jupyter-widgets/?q=cookiecutter&type=all&language=&sort=),
or recipes for creating new custom Jupyter Widgets. While the cookiecutters
initially ensure compatibility with Jupyter and multiple notebook environments, there
can be a steep learning curve for developers unfamiliar with the prescribed
frontend tooling (i.e., `yarn`, Webpack, Babel, ESLint, and Jest are prerequisites) and substantial
effort is **still required to keep the inherited build system up to
date with the latest platform requirements**.

Additionally, the recommended Python build systems
differ significantly between the official templates and are bootstrapped with
features which may or may not be required for a given project. For example, the
JavaScript-based cookiecutter uses (deprecated)
[`jupyter-packaging`](https://github.com/jupyter/jupyter-packaging)
(configured with `setup.py` + `setup.cfg` + `pyproject.toml`), whereas the TypeScript-based
cookiecutter uses the more modern [`hatch-jupyter-builder`](https://github.com/jupyterlab/hatch-jupyter-builder)
plugin for [Hatch](https://github.com/pypa/hatch) (configured with `pyproject.toml`). Understanding
the differences requires knowledge of both modern JavaScript and Python packaging, and
rolling a solution from scratch is [_very_ challenging to do correctly](https://twitter.com/trevmanz/status/1491815033734668288).
In the end, the easiest path forward is to just pick a template and treat it like a blackbox ... until something breaks.

<blockquote>

For the curious reader, I created two separate projects for a `mywidget` package using the
official cookiecutters and included the generated directories below.

<br />

This section not intended to critique the design choices by the Jupyter team and community members – **these recipes
work are used widely** - but to illustrate the surface area a widget author is responsible for understanding and maintaining after project initialization.
For anyone who has used `create-react-app`, it is reminiscent of running `react-script eject` and
vendoring all the build scripts.

<br />

<details>

    <summary>See all 19 files for [`jupyter-widgets/widget-cookiecutter`](https://github.com/jupyter-widgets/widget-cookiecutter)</summary>

    <br/>

    **Summary**

    - Uses (deprecated) [`jupyter-packaging`](https://github.com/jupyter/jupyter-packaging) build system (configured with `setup.py`, `setup.cfg`, & `pyproject.toml`)
    - Uses Webpack to bundle multiple JavaScript targets

    <br/>

    **Command**

    ```
    cookiecutter https://github.com/jupyter/widget-cookiecutter.git@134946a
    ```

    <br/>

    **Output**

    ```
    mywidget
    ├── install.json
    ├── js
    │  ├── amd-public-path.js
    │  ├── lib
    │  │  ├── example.js
    │  │  ├── extension.js
    │  │  ├── index.js
    │  │  └── labplugin.js
    │  ├── package.json
    │  ├── README.md
    │  └── webpack.config.js
    ├── MANIFEST.in
    ├── mywidget
    │  ├── __init__.py
    │  ├── _version.py
    │  └── example.py
    ├── mywidget.json
    ├── pyproject.toml
    ├── README.md
    ├── RELEASE.md
    ├── setup.cfg
    └── setup.py
    ```

</details>

<br />

<details>

    <summary>See all 53 files for [`jupyter-widgets/widget-ts-cookiecutter`](https://github.com/jupyter-widgets/widget-ts-cookiecutter)</summary>

    <br/>

    **Summary**

    - 53 files
    - Uses modern [`hatch-jupyter-builder`](https://github.com/jupyterlab/hatch-jupyter-builder) build system (configured with `pyproject.toml` only)
    - Uses Webpack to bundle multiple JavaScript targets
    - Includes TypeScript, ESLint, Jest, Babel, codecov
    - Includes documentation

    <br/>

    **Command**

    ```
    cookiecutter https://github.com/jupyter-widgets/widget-ts-cookiecutter.git@94f9d38
    ```

    <br/>

    **Output**

    ```
    mywidget
    ├── babel.config.js
    ├── codecov.yml
    ├── css
    │  └── widget.css
    ├── docs
    │  ├── environment.yml
    │  ├── make.bat
    │  ├── Makefile
    │  └── source
    │     ├── _static
    │     │  └── helper.js
    │     ├── conf.py
    │     ├── develop-install.rst
    │     ├── examples
    │     │  ├── index.rst
    │     │  └── introduction.nblink
    │     ├── index.rst
    │     ├── installing.rst
    │     └── introduction.rst
    ├── examples
    │  └── introduction.ipynb
    ├── install.json
    ├── jest.config.js
    ├── LICENSE.txt
    ├── MANIFEST.in
    ├── mywidget
    │  ├── __init__.py
    │  ├── _frontend.py
    │  ├── _version.py
    │  ├── example.py
    │  ├── nbextension
    │  │  └── extension.js
    │  └── tests
    │     ├── __init__.py
    │     ├── conftest.py
    │     ├── test_example.py
    │     └── test_nbextension_path.py
    ├── mywidget.json
    ├── package.json
    ├── pyproject.toml
    ├── pytest.ini
    ├── README.md
    ├── readthedocs.yml
    ├── setup.py
    ├── src
    │  ├── __tests__
    │  │  ├── index.spec.ts
    │  │  └── utils.ts
    │  ├── extension.ts
    │  ├── index.ts
    │  ├── plugin.ts
    │  ├── version.ts
    │  └── widget.ts
    ├── tsconfig.eslint.json
    ├── tsconfig.json
    └── webpack.config.js
    ```

</details>

<br />

It is worth noting that this maintenance surface area is incurred for
each project derived from the cookiecutters.

</blockquote>

Besides the frontend packaging problem, a key limitation in the current
state of Jupyter Widgets is that **prototyping requires the creation and installation of a
new Python package** due to the mechanism by which Jupyter **discovers** widget frontend
code. Prototyping _must_ be done in either a classic Jupyter notebook
or JupyterLab\* where the custom widget extensions have been registered manually
to each of these environments.

```bash
# mywidget/

# install the Python package
pip install -e .

# add extension to classic Jupyter notebook
jupyter nbextension install --py --symlink --overwrite --sys-prefix mywidget
jupyter nbextension enable --py --sys-prefix mywidget

# add extension to JupyterLab
jupyter labextension develop --overwrite mywidget

# rebuild the JavaScript when you make changes ...
yarn run build
```

This requirement creates a barrier to entry for many new Python
and JavaScript programmers. Whereas regular Python modules can be prototyped
in standalone `.py` files or even notebook cells and gradually transitioned to
pip-installable packages, widgets _must_ be `pip` installed from the beginning.

> \*To my knowledge, it is not possible to develop custom widgets in
> Google Colab or VS Code since the JavaScript code must be published to
> `npm` (and available via a CDN like https://unpkg.com).

Finally, the frontend development ecosystem has matured rapidly over the last decade
to enable instant, precise updates to client code without reloading the page or
blowing away application state. Unfortunately, widget authors do not currently
benefit from these advancements due to the legacy mechanism used by Jupyter frontends
to **load** widget JavaScript. Instead, **full page reloads are required to view
changes applied to the frontend widget code** and development feels sluggish compared
to modern frontend applications.

In summary, Jupyter notebooks are ubiquitous and Jupyter Widgets is the standard framework
to extend notebook output cells in the browser with rich, interactive views or controls
for Python objects in the Jupyter kernel. However, the growing number of notebook environments
tools has resulted in a fragmented ecosystem that assumes reusable widgets are only possible
if widget authors,

- Familiarize themselves with frontend build tooling and packaging
- Solve the same mutli-packaging problem for Jupyter-like targets
- Create new packages to start prototyping
- Use outdated web technologies for live development

## ECMAScript Modules to the Rescue

The complexity involved with packaging custom Jupyter Widgets primarily arises
from the need to transform widget JavaScript to target the various module systems
employed by different notebook environments. But what if this step wasn't
required for _all_ widgets?

First described in 2015, ECMAScript modules (ESM) are now the official
standard format to package JavaScript code for reuse. All major browsers
[support ESM natively](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules),
exposing a **common mechanism to load and execute JavaScript**. ESM wasn't
around when Jupyter and it's derivatives were first created, but support
now exists in _all_ these tools because they run in web browsers!

With ESM, the follow code runs natively in all major browsers without modifications.

```javascript
import * as d3 from "https://esm.sh/d3@7";

export function sayHello(name) {
	console.log(`Hello, ${name}!`);
}

sayHello("world"); // Hello, world!
```

## Introducing anywidget

**anywidget** is a Python library that makes custom Jupyter Widgets easy. It is

<u>**not**</u> a new widgets framework, but rather an abstraction around Jupyter
Widgets using ESM.

**anywidget** is a traditional custom widget whose sole purpose is to

- solve the multi-platform problem, and
- load and execute ESM sent from the Python kernel

In this sense, **anywidget** is really a "meta" framework for authoring new widgets.
Users define ESM and an associated Python class (i.e., the components of a
Jupyter Widget), and **anywidget** takes care of connecting the two.

![overview of anywidget implementation. anywidget loads and executes widget JavaScript code sent from the Python kernel](/anywidget-overview.png)

A consequence of this design is that users do not require intimate knowledge of frontend tooling
to start making custom Jupyter Widgets. Instead, they can begin prototyping directly in standalone `.py`
file or notebook cells–just like regular Python modules! You can even start prototyping in Google Colab
and VS Code.

In practice, the ESM required to connect a JavaScript library with Python is often minimal
and can easily be inlined within the Python module as a string. As **anywidget** projects
mature, however, it is recommended to organize the JavaScript source into separate files
which can eventually be merged into a single optimized ESM file with a bundler. See the
[bundling documentation](/en/bundling) for more information.

Lastly, since **anywidget** bypasses the various platform-specific module systems in favor
of native ESM, users have the option to opt-in to an improved developer experience with
modern frontend development also targeting ESM. The [Vite plugin](/en/bundling#development)
for **anywidget** extends [Vite's](https://vitejs.dev/) development server with precise HMR support for Jupyter Widgets.
Changes made to the JavaScript source during development are **instantly** reflected in all active
output notebook cells without refreshing the page or re-executing the a given cell.

<blockquote>
    Today I released **anywidget** v0.1. You can find it on [GitHub](https://github.com/manzt/anywidget) and 
    [PyPI](https://pypi.org/project/anywidget/). To install, just run

    <br/>

    ```bash
    pip install anywidget
    ```

    <br/>

    I hope using **anywidget** is simple and enjoyable. I have personally found
    it valuable in my work as a visualization researcher to quickly iterate on new
    ideas to interactively explore biomedical datasets.

</blockquote>

## Examples

I have included several examples below demonstrating the **anywidget** API and its key features.
All custom widgets are subclasses of `anywidget.AnyWidget`. Each subclass specifies,

- `_esm` the **required** ECMAScript module for the widget. It must must export `render`
  to define custom rendering logic and initialize dynamic updates for the widget. This is an
  alias for the [`DOMWidgetView.render`](https://ipywidgets.readthedocs.io/en/8.0.2/examples/Widget%20Custom.html#Render-method) method,
  except the `view` is passed as an argument in the function definition.

- `_css` an **optional** CSS stylesheet to load for the widget. It can be a full URL or plain text. Styles are loaded in the global scope if using this feature, so take care in avoid global overrides.

All stateful properties to synchronize with JavaScript and Python are defined via [`traitlets`](https://traitlets.readthedocs.io/en/stable/) with `sync=True` metadata, just like regular Jupyter Widgets!

### A Simple Widget

This example is a reproduction of the starter widget in the [`juypyter-widgets/widget-ts-cookiecutter`](https://github.com/jupyter-widgets/widget-ts-cookiecutter/blob/master/%7B%7Bcookiecutter.github_project_name%7D%7D/src/widget.ts)
cookiecutter template. It demonstrates one-way data binding from the Python kernel to frontend view.
The `render` function registers and event handler to update the text output when the `value` traitlet changes.
the output.

```python
import anywidget
import traitlets

class ExampleWidget(anywidget.AnyWidget):
    _esm = """
    export function render(view) {
        view.el.classList.add('custom-widget');
        function value_changed() {
            view.el.textContent = view.model.get('value');
        }
        value_changed();
        view.model.on('change:value', value_changed);
    }
    """
    _css = """
    .custom-widget {
        background-color: lightseagreen;
        padding: 0px 2px;
    }
    """
    value = traitlets.Unicode("Hello World").tag(sync=True)

ExampleWidget()
```

<div style="background-color: lightseagreen; padding: 0px 2px;">
	Hello, World
</div>

### Two-Way Data Binding

This example is slightly more sophisticated and demonstrates how to synchronize model state
between the widget frontend and Python kernel. The `render` function creates a
`<button>` element and registers an event handler to increment the model `value` when
the button is clicked. A second event handler is registered to update the text
output each time `value` changes on the model.

By treating the model as the source of truth, regardless of whether `value` is updated on the Python side or the JavaScript side, the count displayed remains correct. See the Jupyter Widgets [documentation](https://ipywidgets.readthedocs.io/en/8.0.2/examples/Widget%20Custom.html#Render-method)
to learn more about the model view controller (MCV) framework the IPython widget framework frontend relies on.

```python
import anywidget
import traitlets


class CounterWidget(anywidget.AnyWidget):
    _esm = """
    export function render(view) {
      let count = () => view.model.get("value");
      let btn = document.createElement("button");
      btn.classList.add("counter-button");
      btn.innerHTML = `count is ${count()}`;
      btn.addEventListener("click", () => {
        view.model.set("value", count() + 1);
        view.model.save_changes();
      });
      view.model.on("change:value", () => {
        btn.innerHTML = `count is ${count()}`;
      });
      view.el.appendChild(btn);
    }
    """
    _css="""
    .counter-button { background-color: #ea580c; }
    .counter-button:hover { background-color: #9a3412; }
    """
    value = traitlets.Int(0).tag(sync=True)

counter = CounterWidget()
counter.value = 10
counter
```

<CounterButton size={"lg"} initialValue={10} />

### Third-party dependencies

Any valid ESM is supported by **anywidget**, so dependencies can be imported
directly from a CDN via URL so as long as they are also ESM. Browser
support for modules means these imports are optimized and cached in subsequent
requests.

```python
import anywidget

class ConfettiWidget(anywidget.AnyWidget):
    _esm = """
    import confetti from "https://esm.sh/canvas-confetti@1.6";

    export function render(view) {
      let btn = document.createElement("button");
      btn.classList.add("confetti-button");
      btn.innerHTML = "click me!";
      btn.addEventListener("click", () => {
        confetti();
      });
      view.el.appendChild(btn);
    }
    """
    _css="""
    .confetti-button { background-color: #ea580c; }
    .confetti-button:hover { background-color: #9a3412; }
    """

ConfettiWidget()
```

<ConfettiButton size={"lg"} />

## Limitations

**anywidget** does not currently allow extension of the `DOMWidgetModel`, so custom serialization
and deserialization of traitlets is not currently supported. Additionally, lifecycle hooks
(e.g., `DOMWidgetView.remove()` which can be useful for freeing browser resources) are currently not recognized. I am actively working to support both of these use cases
(and more) via additional ESM exports,

```javascript
export let serializers = {
	/* ... */
};
export function remove() {
	/* ... */
}
export function render(view) {
	/* ... */
}
```

If this is interesting or exciting to you, please reach out and get involved on GitHub! Happy coding.
